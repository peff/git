#!/bin/sh

upstream=`git for-each-ref --format='%(upstream)' refs/heads/private`
upstream=${upstream:-origin}

cont=
force=
noautorerere=
careful=0
test_script=
options=
interactive=
while test $# -gt 0; do
case "$1" in
--continue)
	cont=t
	;;
--noautorerere)
	noautorerere=t
	merge_config="-c rerere.autoupdate=false"
	options="$options $1"
	;;
-f)
	force=t
	;;
-c|--careful)
	careful=$(($careful + 1))
	options="$options $1"
	;;
-t)
	shift
	test_script="$1"
	options="$options -t $1"
	;;
-i)
	interactive=t
	;;
*)
	echo >&2 "unknown option: $1"
	exit 1
esac
shift
done

GIT_DIR=`git rev-parse --git-dir` || exit
TODO_FILE=$GIT_DIR/private-todo

if test "$cont" = t; then
	if git symbolic-ref -q HEAD >/dev/null; then
		echo >&2 "fatal: refusing to continue private build from branch"
		exit 1
	fi
else
	if test -z "$force" && test -e "$TODO_FILE"; then
		echo >&2 "$TODO_FILE already exists"
		exit 1
	fi
	fixup=
	extra=
	tmp="$GIT_DIR/private-commits"
	git rev-list --oneline --no-merges --first-parent $upstream..private >"$tmp"
	while read hash subject; do
		case "$subject" in
		"merge-fixup "*)
			fixup="$fixup $hash:${subject#merge-fixup }"
			;;
		*)
			extra="$extra $hash"
			;;
		esac
	done <"$tmp"
	rm -f "$tmp"

	if test -z "$force" && test -n "$extra"; then
		git log --no-walk $extra
		exit 1
	fi

	git checkout -q ${force:+-f} $upstream^0 || exit
	echo "Meta/private --continue $options" >"$GIT_DIR/continue"

	for i in `Meta/topics`; do
		case "$i" in
		*-wip|*-stale)
			echo >&2 "Skipping $i (wip)..."
			continue
			;;
		esac

		echo "merge $i"
		for f in $fixup; do
			case "$f" in
			*:$i)
				hash=${f%:$i}
				git log -1 --format="pick %h %s" $hash
			esac
		done

		if test "$careful" -gt 0; then
			echo 'exec make -j16'
		fi
		if test "$careful" -gt 1; then
			echo 'exec make test'
		elif test -n "$test_script"; then
			echo "exec test ! -e t/t${test_script}*.sh || { make -j16 && cd t && make t${test_script}*.sh; }"
		fi
	done >"$TODO_FILE"
fi

if test -n "$interactive"; then
	${EDITOR:-vi} "$TODO_FILE"
	if ! test -s "$TODO_FILE"; then
		echo >&2 "Aborting due to empty todo file..."
		rm -f "$TODO_FILE"
		exit 1
	fi
fi

# failing not only involves exiting, but also cleaning up the todo list
# (dropping entries done, but keeping ones we didn't get to yet).
# Any arguments given to this function will be unshifted onto the front of the
# list.
fail () {
	{
		for i in "$@"; do
			echo "$i"
		done
		cat ;# stdin is already coming from existing list
	} >"$TODO_FILE".tmp
	mv "$TODO_FILE".tmp "$TODO_FILE"
	exit 1
}

while read cmd args; do
	case "$cmd" in
	merge)
		echo >&2 "Merging $args..."
		if ! git $merge_config merge --no-edit --no-ff $args; then
			if test -z "$noautorerere" && test -z "`git ls-files -u`"; then
				echo >&2 "Auto-committing rerere merge..."
				git commit --no-edit || fail "resolve $args"
			else
				fail "resolve $args"
			fi
		fi
		;;
	resolve)
		echo >&2 "Resolving $args..."
		git diff-index --quiet HEAD ||
			git commit --no-edit || fail "resolve $args"
		;;
	pick)
		echo >&2 "Picking $args..."
		if ! git cherry-pick ${args%% *}; then
			if git diff-index --quiet HEAD; then
				echo >&2 "Discarding empty cherry-pick..."
				git cherry-pick --skip || fail "resolve $args"
			else
				fail "resolve $args"
			fi
		fi
		;;
	exec)
		eval "($args)" || fail
		;;
	esac
done <"$TODO_FILE"

git branch -f private &&
git checkout private || exit
rm -f "$GIT_DIR/continue" "$TODO_FILE"
echo All branches merged successfully.
exit 0
