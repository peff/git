#!/bin/bash

WORKTREE_ROOT=.git/tmp-ci

test $# = 0 && set -- --status

if test "$1" = "--status"; then
	git test run -k --dry-run @{u}.. 2>/dev/null |
	while read tree line; do
		case "$line" in
		known-good)
			printf 'G'
			;;
		known-bad)
			printf 'B'
			;;
		unknown)
			printf '.'
			;;
		*)
			printf '?'
			;;
		esac
	done
	echo
	exit 0
fi

if test "$1" = "-v"; then
	paste -d' ' <(
		git test run -k --dry-run @{u}.. 2>/dev/null | awk '{print $2}'
	) <(
		git test run -k --dry-run @{u}.. 2>/dev/null | cut -d^ -f1 |
			git log --color --stdin --no-walk=unsorted --oneline
	)
	exit 0
fi

if test "$1" = "--daemon"; then
	shift
fi

enter_worktree() {
	test -d "$1" ||
	git worktree add --detach -f "$1" ||
	return 1

	test -e "$1/config.mak" ||
	ln -s "$(echo "$1" | sed 's/[^/]*/../g')/config.mak" "$1/config.mak" ||
	return 1

	cd "$1"
}

test_one() {
	if ! branch=$(git symbolic-ref --short HEAD 2>/dev/null); then
		echo >&2 "skipping tests on a detached HEAD"
		return 0
	fi
	if test "$branch" = "private"; then
		echo >&2 "skipping tests on private branch"
		return 0
	fi
	if ! git rev-parse --verify "$branch@{u}" >/dev/null 2>&1; then
		echo >&2 "skipping tests on branch without upstream: $branch"
		return 0
	fi

	(
		enter_worktree "$WORKTREE_ROOT" &&
		# we only care about "bad". "good" etc are obviously
		# fine. "known-bad" is a failure, but one we already
		# knew about, and so we avoid triggering the failure
		# actions.
		! git test run "$@" "$branch@{u}..$branch" |
		grep ' bad$'
	)
}

handle_outcome() {
	script=$(git config --get-all "test.on$1" 2>/dev/null)
	eval "$script"
}

while true; do
	echo "==> $(date)"
	if test_one "$@"; then
		handle_outcome success
	else
		handle_outcome failure
	fi

	gitdir=$(git rev-parse --git-dir)
	# We need delete_self to pick up changes to HEAD (since it gets renamed
	# over), and "move" to pick up changes in the refs directories.
	inotifywait -qq -t 60 -e delete_self -e move -r "$gitdir/HEAD" "$gitdir/refs"
done
